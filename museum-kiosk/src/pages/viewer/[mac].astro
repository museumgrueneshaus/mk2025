---
import KioskLayout from '../../layouts/KioskLayout.astro';
import kiosksData from '../../../public/config/kiosks.json';

// Import all templates
import SlideshowAuto from '../../layouts/templates/SlideshowAuto.astro';
import ImageGallery from '../../layouts/templates/ImageGallery.astro';
import PDFViewer from '../../layouts/templates/PDFViewer.astro';
import KnowledgeBase from '../../layouts/templates/KnowledgeBase.astro';
import KnowledgeBaseExtended from '../../layouts/templates/KnowledgeBaseExtended.astro';
import VideoPlayer from '../../layouts/templates/VideoPlayer.astro';
import ExternalURL from '../../layouts/templates/ExternalURL.astro';
import MixedCarousel from '../../layouts/templates/MixedCarousel.astro';
import IframeEmbed from '../../layouts/templates/IframeEmbed.astro';
import EventCalendar from '../../layouts/templates/EventCalendar.astro';

// Generate static pages for known kiosk IDs
export async function getStaticPaths() {
  // Generate paths for pi_01 through pi_10
  const paths = [];
  for (let i = 1; i <= 10; i++) {
    const id = `pi_${i.toString().padStart(2, '0')}`;
    paths.push({ params: { mac: id } });
  }
  
  // Also include the default test MACs
  paths.push({ params: { mac: 'aa-bb-cc-dd-ee-01' } });
  paths.push({ params: { mac: 'aa-bb-cc-dd-ee-02' } });
  paths.push({ params: { mac: 'aa-bb-cc-dd-ee-03' } });
  paths.push({ params: { mac: 'aa-bb-cc-dd-ee-04' } });
  
  return paths;
}

// Enable static generation
export const prerender = true;

const { mac } = Astro.params;

// Load kiosk configuration directly
const kiosks = kiosksData;
const config = kiosks[mac] || kiosks['aa-bb-cc-dd-ee-01'] || {
  name: 'Default',
  layout: 'slideshow-auto',
  content: {
    images: [
      'https://images.unsplash.com/photo-1565043666747-69f6646db940?w=1920&h=1080&fit=crop',
      'https://images.unsplash.com/photo-1513038630932-13873b1a7f29?w=1920&h=1080&fit=crop'
    ]
  }
};

// Map layout types to components
const layoutComponents = {
  'slideshow-auto': SlideshowAuto,
  'image-gallery': ImageGallery,
  'pdf-viewer': PDFViewer,
  'knowledge-base': KnowledgeBase,
  'knowledge-base-extended': KnowledgeBaseExtended,
  'video-player': VideoPlayer,
  'external-url': ExternalURL,
  'mixed-carousel': MixedCarousel,
  'iframe-embed': IframeEmbed,
  'event-calendar': EventCalendar
};

const LayoutComponent = layoutComponents[config.layout] || SlideshowAuto;
---

<KioskLayout title={`Kiosk - ${config.name}`} isKiosk={true}>
  <main class="kiosk-viewer">
    <LayoutComponent config={config} />
    
    <!-- Idle Overlay -->
    <div id="idle-overlay" class="idle-overlay" style="display: none;">
      <div class="idle-content">
        <div class="idle-icon">
          <svg width="80" height="80" viewBox="0 0 24 24" fill="white">
            <path d="M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"/>
          </svg>
        </div>
        <h2 class="idle-title">Berühren Sie den Bildschirm</h2>
        <p class="idle-subtitle">Touch to continue • Touchez pour continuer</p>
      </div>
    </div>
  </main>
  
  <!-- Debug Info (nur in Development) -->
  {import.meta.env.DEV && (
    <div class="debug-info">
      MAC: {mac}<br/>
      Layout: {config.layout}<br/>
      Kiosk: {config.name}
    </div>
  )}
</KioskLayout>

<style>
  .kiosk-viewer {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #000;
    position: relative;
  }
  
  .idle-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    cursor: pointer;
  }

  .idle-content {
    text-align: center;
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { 
      transform: scale(1); 
      opacity: 0.8;
    }
    50% { 
      transform: scale(1.05); 
      opacity: 1;
    }
  }

  .idle-icon {
    margin-bottom: 20px;
  }

  .idle-title {
    color: white;
    font-size: 2rem;
    margin-bottom: 10px;
    font-weight: 300;
  }

  .idle-subtitle {
    color: rgba(255, 255, 255, 0.7);
    font-size: 1rem;
  }
  
  .debug-info {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: #0f0;
    padding: 10px;
    font-family: monospace;
    font-size: 12px;
    z-index: 10000;
    pointer-events: none;
  }
</style>

<script define:vars={{ config }}>
  // Idle detection
  let idleTimer: NodeJS.Timeout;
  let idleOverlay = document.getElementById('idle-overlay');
  const IDLE_TIME = (config.idle?.showInstructions || 30) * 1000;
  const RESET_TIME = (config.idle?.backToStart || 120) * 1000;
  
  function resetIdleTimer() {
    clearTimeout(idleTimer);
    
    // Hide overlay if visible
    if (idleOverlay) {
      idleOverlay.style.display = 'none';
    }
    
    // Set new timer
    idleTimer = setTimeout(() => {
      if (idleOverlay) {
        idleOverlay.style.display = 'flex';
      }
      
      // After more time, reload page
      setTimeout(() => {
        window.location.reload();
      }, RESET_TIME - IDLE_TIME);
    }, IDLE_TIME);
  }

  // Events that reset idle timer
  ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'].forEach(event => {
    document.addEventListener(event, resetIdleTimer, { passive: true });
  });

  // Start idle timer
  resetIdleTimer();

  // Click on overlay to dismiss
  if (idleOverlay) {
    idleOverlay.addEventListener('click', resetIdleTimer);
  }

  // Auto-refresh content every 30 minutes
  setInterval(() => {
    // Check for config updates
    fetch(`/config/kiosks.json?t=${Date.now()}`)
      .then(res => res.json())
      .then(data => {
        const mac = window.location.pathname.split('/').pop();
        const newConfig = data[mac];
        if (newConfig && JSON.stringify(newConfig) !== JSON.stringify(config)) {
          window.location.reload();
        }
      })
      .catch(err => console.error('Config check failed:', err));
  }, 30 * 60 * 1000);

  // Fullscreen on first interaction
  document.addEventListener('click', () => {
    if (!document.fullscreenElement && !import.meta.env.DEV) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log(`Fullscreen error: ${err.message}`);
      });
    }
  }, { once: true });
</script>